// Copyright (c) 2018-2021, The Decred developers
// Copyright (c) 2017, Jonathan Chappelow
// See LICENSE for details.

package mempoolltc

import (
	"fmt"
	"sort"
	"sync"
	"time"

	exptypes "github.com/decred/dcrdata/v8/explorer/types"
	"github.com/decred/dcrdata/v8/txhelpers"
	"github.com/ltcsuite/ltcd/btcjson"
	"github.com/ltcsuite/ltcd/chaincfg"
	"github.com/ltcsuite/ltcd/chaincfg/chainhash"
	"github.com/ltcsuite/ltcd/ltcutil"
)

// txhelpers.VerboseTransactionPromiseGetter.
type NodeClient interface {
	GetRawMempoolVerbose() (map[string]btcjson.GetRawMempoolVerboseResult, error)
	GetBestBlock() (*chainhash.Hash, int32, error)
	txhelpers.LTCRawTransactionGetter
	txhelpers.LTCVerboseTransactionGetter
	GetBlockHeaderVerbose(hash *chainhash.Hash) (*btcjson.GetBlockHeaderVerboseResult, error)
}

type CoreNodeClient interface {
	GetTxOutSetInfo() (*btcjson.GetTxOutSetInfoResult, error)
}

// DataCollector is used for retrieving and processing data from a chain
// server's mempool.
type DataCollector struct {
	// Mutex is used to prevent multiple concurrent calls to Collect.
	mtx             sync.Mutex
	ltcdChainSvr    NodeClient
	ltcCoreChainSvr CoreNodeClient
	activeChain     *chaincfg.Params
}

// NewDataCollector creates a new DataCollector. Use a rpcutils.AsyncTxClient to
// create a NodeClient from an rpcclient.Client or implement a wrapper that
// provides txhelpers.VerboseTransactionPromiseGetter.
func NewDataCollector(ltcdChainSvr NodeClient, ltcCoreChainSvr CoreNodeClient, params *chaincfg.Params) *DataCollector {
	return &DataCollector{
		ltcdChainSvr:    ltcdChainSvr,
		ltcCoreChainSvr: ltcCoreChainSvr,
		activeChain:     params,
	}
}

// mempoolTxns retrieves all transactions and returns them as a
// []exptypes.MempoolTx. See also ParseTxns, which may process this slice. A
// fresh MempoolAddressStore and TxnsStore are also generated.
func (t *DataCollector) Collect() (*BlockID, []exptypes.MempoolTx, txhelpers.LTCMempoolAddressStore, txhelpers.LTCTxnsStore, error) {
	mempooltxs, err := t.ltcdChainSvr.GetRawMempoolVerbose()
	if err != nil {
		return nil, nil, nil, nil, fmt.Errorf("GetRawMempoolVerbose failed: %v", err)
	}

	bestHash, bestHeight, err := t.ltcdChainSvr.GetBestBlock()
	if err != nil {
		return nil, nil, nil, nil, err
	}
	header, err := t.ltcdChainSvr.GetBlockHeaderVerbose(bestHash)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	blockTime := header.Time
	blockId := &BlockID{
		Hash:   *bestHash,
		Height: int64(bestHeight),
		Time:   blockTime,
	}

	txs := make([]exptypes.MempoolTx, 0, len(mempooltxs))
	addrMap := make(txhelpers.LTCMempoolAddressStore)
	txnsStore := make(txhelpers.LTCTxnsStore)

	for hashStr, tx := range mempooltxs {
		hash, err := chainhash.NewHashFromStr(hashStr)
		if err != nil {
			log.Warn(err)
			continue
		}
		txn, err := t.ltcdChainSvr.GetRawTransaction(hash)
		if err != nil {
			log.Warn(err)
			continue
		}
		msgTx := txn.MsgTx()

		// Set Outpoints in the addrMap.

		txhelpers.LTCTxOutpointsByAddr(addrMap, msgTx, t.activeChain)
		// Set PrevOuts in the addrMap, and related txns data in txnsStore.
		txhelpers.LTCTxPrevOutsByAddr(addrMap, txnsStore, msgTx, t.ltcdChainSvr, t.activeChain)

		// Store the current mempool transaction with MemPoolTime from GRM, and
		// block info zeroed.
		txnsStore[*hash] = &txhelpers.LTCTxWithBlockData{
			Tx:          msgTx,
			MemPoolTime: tx.Time,
		}

		var totalOut int64
		for _, v := range msgTx.TxOut {
			totalOut += v.Value
		}

		_, feeRate := txhelpers.LTCTxFeeRate(msgTx, t.ltcdChainSvr)

		txs = append(txs, exptypes.MempoolTx{
			TxID:      hashStr,
			Version:   int32(msgTx.Version),
			Fees:      tx.Fee,
			FeeRate:   feeRate.ToBTC(),
			VinCount:  len(msgTx.TxIn),
			VoutCount: len(msgTx.TxOut),
			Vin:       exptypes.LTCMsgTxMempoolInputs(msgTx),
			// Coinbase:  txhelpers.IsCoinBaseTx(msgTx), // commented because coinbase is not in mempool
			Hash:     hashStr, // dup of TxID!
			Time:     tx.Time,
			Size:     tx.Size,
			TotalOut: ltcutil.Amount(totalOut).ToBTC(),
		})
	}

	return blockId, txs, addrMap, txnsStore, nil
}

// NumLatestMempoolTxns is the maximum number of mempool transactions that will
// be stored in the LatestTransactions field of the MempoolInfo generated by
// ParseTxns.
const NumLatestMempoolTxns = 5

// ParseTxns analyzes the mempool transactions in the txs slice, and generates a
// MempoolInfo summary with categorized transactions.
func ParseTxns(txs []exptypes.MempoolTx, params *chaincfg.Params, lastBlock *BlockID) *exptypes.MutilchainMempoolInfo {
	// The txs slice needs to be sorted by time, but we do not want to modify
	// the slice outside of this function and we do not want to waste time
	if !sort.SliceIsSorted(txs, func(i, j int) bool {
		return txs[i].Time > txs[j].Time
	}) {
		log.Debug("The transactions slice was not sorted by time. Sorting it now.")
		// Copy the input slice to avoid side effects.
		txs0 := txs
		txs = make([]exptypes.MempoolTx, len(txs0))
		copy(txs, txs0)
		sort.Sort(exptypes.MPTxsByTime(txs))
	}

	blockhash := lastBlock.Hash.String()

	// Reduction variables.
	var latestTime int64
	var totalOut ltcutil.Amount
	var totalSize int32
	var totalFee = float64(0)
	totalVouts := int64(0)
	for _, tx := range txs {
		totalVouts += int64(tx.VoutCount)
		out, _ := ltcutil.NewAmount(tx.TotalOut) // 0 for invalid amounts
		totalOut += out
		totalSize += tx.Size
		if latestTime < tx.Time {
			latestTime = tx.Time
		}
		totalFee += tx.Fees
	}

	formattedSize := exptypes.BytesString(uint64(totalSize))

	// Store mempool data for template rendering
	mpInfo := exptypes.MutilchainMempoolInfo{
		LastBlockHeight:    lastBlock.Height,
		LastBlockHash:      blockhash,
		LastBlockTime:      lastBlock.Time,
		FormattedBlockTime: (exptypes.TimeDef{T: time.Unix(lastBlock.Time, 0)}).String(),
		Time:               latestTime,
		TotalOut:           totalOut.ToBTC(),
		TotalSize:          totalSize,
		FormattedTotalSize: formattedSize,
		Transactions:       txs,
		TotalTransactions:  int64(len(txs)),
		TotalFee:           totalFee,
		OutputsCount:       totalVouts,
	}

	return &mpInfo
}
